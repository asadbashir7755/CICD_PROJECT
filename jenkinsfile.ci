pipeline {
    agent { label 'ubuntuagent' }

    environment {
        // Backend vars
        DOCKER_BACKEND_IMAGE        = "${DOCKER_BACKEND_IMAGE}"
        ACCESS_COOKIE_MAXAGE        = "3600000"
        ACCESS_TOKEN_EXPIRES_IN     = "1h"
        REFRESH_COOKIE_MAXAGE       = "120000"
        REFRESH_TOKEN_EXPIRES_IN    = "7d"
        BACKEND_PORT_HOST           = "${BACKEND_PORT_HOST}"
        BACKEND_PORT_CONTAINER      = "${BACKEND_PORT_CONTAINER}"
        BACKEND_IMAGE_TAG           = "${BACKEND_IMAGE_TAG}"
        FRONTEND_IMAGE_TAG          = "${FRONTEND_IMAGE_TAG}"

        // Frontend vars
        DOCKER_FRONTEND_IMAGE       = "${DOCKER_FRONTEND_IMAGE}"
        FRONTEND_PORT_HOST          = "${FRONTEND_PORT_HOST}"
        FRONTEND_PORT_CONTAINER     = "${FRONTEND_PORT_CONTAINER}"

        // Database name
        MONGO_INITDB_DATABASE       = "${MONGO_INITDB_DATABASE}"
    }

    stages {

        stage("CISTART") {
            steps { echo "CI PIPELINE IS RUNNING..." }
        }

        stage('Checkout') {
            steps {
                git url: 'https://github.com/asadbashir7755/CICD_PROJECT.git', branch: 'main'
            }
        }

        stage('Tests') {
            parallel {
                stage('TestBackend') {
                    steps {
                        script {
                            // Create a cache directory for node_modules
                            def backendCacheDir = "${WORKSPACE}/.cache/backend_node_modules"

                            sh """
                            # Run backend tests in Node Docker container
                            docker run --rm \\
                                -v ${WORKSPACE}/backend:/app \\
                                -v ${backendCacheDir}:/app/node_modules \\
                                -w /app \\
                                -e NODE_ENV=test \\
                                node:18-alpine sh -c "
                                
                                # Install dependencies (cached)
                                if [ ! -d node_modules ]; then npm ci; fi
                                
                                # Run unit tests with coverage
                                npm run test:unit -- --coverage --coverageDirectory=coverage --reporters=default --reporters=jest-junit
                                "
                            """
                        }
                    }
                    post {
                        always {
                            // Archive test reports and coverage
                            junit 'backend/coverage/junit.xml'
                            archiveArtifacts artifacts: 'backend/coverage/lcov-report/**', allowEmptyArchive: true
                        }
                    }
                }

        stage('TestFrontend') {
            steps {
                script {
                    def frontendCacheDir = "${WORKSPACE}/.cache/frontend_node_modules"

                    sh """
                    docker run --rm \\
                        -v ${WORKSPACE}/frontend:/app \\
                        -v ${frontendCacheDir}:/app/node_modules \\
                        -w /app \\
                        -e NODE_ENV=test \\
                        node:18-alpine sh -c "
                        
                        # Install dependencies (cached)
                        if [ ! -d node_modules ]; then npm ci; fi
                        
                        # Run frontend tests with coverage
                        npm test -- --coverage --coverageDirectory=coverage --reporters=default --reporters=jest-junit
                        "
                    """
                }
            }
            post {
                always {
                    junit 'frontend/coverage/junit.xml'
                    archiveArtifacts artifacts: 'frontend/coverage/lcov-report/**', allowEmptyArchive: true
                }
            }
        }
    }
}


        stage('BuildBackend') {
            steps {
                sh 'docker build -t $DOCKER_BACKEND_IMAGE ./backend'
            }
        }

        stage('BuildFrontend') {
            steps {
                sh 'docker build -t $DOCKER_FRONTEND_IMAGE -f frontend/Dockerfile .'
            }
        }

        stage('Push images to docker hub') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'dockerhublogin',
                        usernameVariable: 'USER',
                        passwordVariable: 'PASS'
                    )
                ]) {

                    sh '''
                        docker login -u $USER -p $PASS

                        # Tag images correctly using your dockerhub username
                        docker tag $DOCKER_BACKEND_IMAGE $DOCKER_BACKEND_IMAGE:$BACKEND_IMAGE_TAG
                        docker tag $DOCKER_FRONTEND_IMAGE $DOCKER_FRONTEND_IMAGE:$FRONTEND_IMAGE_TAG

                        # Push images
                        docker push $DOCKER_BACKEND_IMAGE:$BACKEND_IMAGE_TAG
                        docker push $DOCKER_FRONTEND_IMAGE:$FRONTEND_IMAGE_TAG
                    '''
                }
            }
        }

        stage("CD_DOCKERCOMPOSE") {
            steps {
                withCredentials([
                    string(credentialsId: 'JWT_SECRET', variable: 'JWT_SECRET'),
                    string(credentialsId: 'MONGO_INITDB_ROOT_USERNAME', variable: 'MONGO_INITDB_ROOT_USERNAME'),
                    string(credentialsId: 'MONGO_INITDB_ROOT_PASSWORD', variable: 'MONGO_INITDB_ROOT_PASSWORD'),
                    string(credentialsId: 'GOOGLE_CLIENT_ID', variable: 'GOOGLE_CLIENT_ID'),
                    string(credentialsId: 'GOOGLE_CLIENT_SECRET', variable: 'GOOGLE_CLIENT_SECRET'),
                    string(credentialsId: 'REDIS_PASSWORD', variable: 'REDIS_PASSWORD')
                ]) {

                    dir("${WORKSPACE}") {

                        sh '''
                        echo "Creating .env file..."

                        cat > .env <<EOF
PORT=8000

DOCKER_BACKEND_IMAGE=$DOCKER_BACKEND_IMAGE
ACCESS_COOKIE_MAXAGE=$ACCESS_COOKIE_MAXAGE
ACCESS_TOKEN_EXPIRES_IN=$ACCESS_TOKEN_EXPIRES_IN
REFRESH_COOKIE_MAXAGE=$REFRESH_COOKIE_MAXAGE
REFRESH_TOKEN_EXPIRES_IN=$REFRESH_TOKEN_EXPIRES_IN
BACKEND_PORT_HOST=$BACKEND_PORT_HOST
BACKEND_PORT_CONTAINER=$BACKEND_PORT_CONTAINER
BACKEND_IMAGE_TAG=$BACKEND_IMAGE_TAG

FRONTEND_IMAGE_TAG=$FRONTEND_IMAGE_TAG
DOCKER_FRONTEND_IMAGE=$DOCKER_FRONTEND_IMAGE
FRONTEND_PORT_HOST=$FRONTEND_PORT_HOST
FRONTEND_PORT_CONTAINER=$FRONTEND_PORT_CONTAINER
MONGO_INITDB_DATABASE=$MONGO_INITDB_DATABASE

// credentials
JWT_SECRET="$JWT_SECRET"
MONGO_INITDB_ROOT_USERNAME="$MONGO_INITDB_ROOT_USERNAME"
MONGO_INITDB_ROOT_PASSWORD="$MONGO_INITDB_ROOT_PASSWORD"
GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID"
GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET"
REDIS_PASSWORD="$REDIS_PASSWORD"

MONGODB_URI=mongodb://$MONGO_INITDB_ROOT_USERNAME:$MONGO_INITDB_ROOT_PASSWORD@mongodb:27017/wanderlust?authSource=admin
REDIS_URL=redis://:$REDIS_PASSWORD@redis:6379

EOF

                        echo "Starting docker compose..."
                        
                        docker compose --env-file .env -f infra/dockercompose.prod.yml up -d

                        '''
                    }
                }
            }
        }

        stage("CIEND") {
            steps { echo "CI PIPELINE FINISHED" }
        }
    }
}
